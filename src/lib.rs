/*! Allows for "hydrating" an existent DOM with reactive leptos components,
 * without the entire DOM having to be generated by leptos components.
 * 
 * ## Why would you want that?
 * 1. **CSR:** It allows for building scripts that others can just embed in their arbitrary HTML documents, that adds `<insert your favourite fancy feature here>`. For an example, see the `examples/csr` directory: the `index.html` has a node `<script src='csr_example.js'></script>`, which "hydrates" selected nodes (with the `data-replace-with-leptos`-attribute) with leptos components that add a hover-popup (using [thaw](https://docs.rs/thaw)). You too can now do the same for any HTML document you want by just adding the script tag.
 * 2. **SSR:** Occasionally, you might want to dynamically insert some HTML string into the DOM, for example one that gets generated from some data and returned by a server function. This HTML might contain certain nodes that we want to attach reactive functionality to.
 * 
 * ## CSR Example
 * Say we want to replace all elements with the attribute `data-replace-with-leptos` with a leptos component `MyReplacementComponent`, that simply wraps the original children in a `div` with a solid red border. This component would roughly look like this:
 * ```
 * #[component]
 * fn MyReplacementComponent(orig:OriginalChildren) -> impl IntoView {
 *    view! {
 *       <div style="border: 1px solid red;">
 *         <DomChildren orig />
 *      </div>
 *   }
 * }
 * ```
 * This component takes an `orig:`[`OriginalChildren`] that represents the "children the original node used to have". They get reinserted where we use the [`DomChildren`] component - i.e. wrapped in a `div` with a red border.
 * 
 * So, where do we get `orig` from? 
 * - If we already have an `e:&`[`Element`], we can simply call [`OriginalChildren::new`]`(e)`. That will immediately remove *all* children of `e` and move them into the returned [`OriginalChildren`]. Trouble then is, that the component likely doesn't know where in leptos' reactive graph it should be inserted regarding reactivity (i.e. inheriting context and all that).
 * - More likely, we don't have an [`Element`] yet. Moreover, we probably want to iterate over the entire body *once* to find all nodes we want to make reactive, and we also need to set up a global reactive system for all our inserted components.
 * 
 * To do that, we call [`hydrate_body`] (requires the `csr` feature flag) with a function that takes the [`OriginalChildren`] of the body and returns some leptos view; e.g.:
 * 
 * ```
 *  #[component]
 *  fn MainBody(orig:OriginalChildren) -> impl IntoView {
 *     // set up some signals, provide context etc.
 *     view!{
 *       <DomChildren orig/>
 *     }
 *  }
 *  #[wasm_bindgen(start)]
 *   pub fn run() {
 *       console_error_panic_hook::set_once();
 *       hydrate_body(|orig| view!(<MainBody orig/>).into_any())
 *   }
 * ```
 * 
 * This sets up the reactive system, but does not yet replace any elements further down in the DOM. To do that, we provide a function that takes an `&`[`Element`] and optionally returns an [`AnyView`]`<`[`Dom`]`>`, if the element should be changed. This function is then passed to [`DomChildrenCont`], which will iterate over all children of the replaced element and replace them with the provided function.
 * 
 * Let's modify our `MainBody` to replace all elements with the attribute `data-replace-with-leptos` with a `MyReplacementComponent`:
 * 
 * ```
 *  fn replace(e:&Element) -> Option<AnyView<Dom>> {
 *    e.get_attribute("data-replace-with-leptos").map(|_| {
 *      let orig = OriginalChildren::new(e);
 *      view!(<MyReplacementComponent orig/>).into_any()
 *    })
 *  }
 * 
 *  #[component]
 *  fn MainBody(orig:OriginalChildren) -> impl IntoView {
 *     // set up some signals, provide context etc.
 *     view!{
 *       <DomChildrenCont orig f=replace/>
 *     }
 *  }
 * 
 * #[component]
 * fn MyReplacementComponent(orig:OriginalChildren) -> impl IntoView {
 *    view! {
 *       <div style="border: 1px solid red;">
 *         <DomChildrenCont orig f=replace/>
 *      </div>
 *   }
 * }
 * ```
 * 
 * ...now, `replace` will get called on every element of the DOM, including those that were "moved around" in earlier `MyReplacementComponent`s, respecting the reactive graph properly hierarchically.
 * 
 * ### SSR Example
 * 
 * In general, for SSR we can simply use the normal leptos components to generate the entire DOM. We control the server, hence we control the DOM anyway.
 * 
 * However, it might occasionally be the case that we want to dynamically *extend* the DOM at some point by retrieving HTML from elsewhere, and then want to do a similar "hydration" iteration over the freshly inserted nodes. This is what [`DomStringCont`] is for, and it does not require the `csr` feature:
 * 
 * ```
 *  #[component]
 *  fn MyComponentThatGetsAStringFromSomewhere() -> impl IntoView {
 *   // get some HTML string from somewhere
 *   // e.g. some API call
 *   let html = "<div data-replace-with-leptos>...</div>".to_string();
 *   view! {
 *     <DomStringCont html f=replace/>
 *   }
 * }
 * ```
 * 
 * See the `examples/ssr` directory for a full example.
*/

pub use dom::OriginalChildren;

#[cfg(any(feature="csr",feature="hydrate"))]
pub use dom::hydrate_node;

/// Re-exports `web_sys::Element` for convenience.
pub use web_sys::Element;

use leptos::{ html::{ElementType, Span}, math::Mrow, prelude::*};
use tachys::view::any_view::AnyView;

mod dom;


/// A component that takes the [`OriginalChildren`] of some preexistent DOM node, and renders them into the DOM.
#[component]
pub fn DomChildren(orig:OriginalChildren) -> impl IntoView {
    let span = NodeRef::<Span>::new();
    replace(span,orig,Option::<for<'a> fn(&'a _) -> _>::None);
    view!(<span node_ref=span/>)
}

/// Like [`DomChildren`], but using `<mrow>` instead of `<span>`.
#[component]
pub fn DomChildrenMath(orig:OriginalChildren) -> impl IntoView {
    let span = NodeRef::<Mrow>::new();
    replace(span,orig,Option::<for<'a> fn(&'a _) -> _>::None);
    view!(<mrow node_ref=span/>)
}


/// A component that takes the [`OriginalChildren`] of some preexistent DOM node and a continuation function `f`, and renders them into the DOM. Additionally, `f` is called on every child of the replaced element, to potentially "hydrate" them further.
#[component]
pub fn DomChildrenCont<F:Fn(&Element) -> Option<AnyView<Dom>>+'static+Clone>(orig:OriginalChildren,f:F) -> impl IntoView {
    let span = NodeRef::<Span>::new();
    replace(span,orig,Some(f));
    view!(<span node_ref=span/>)
}

/// Like [`DomChildrenCont`], but using `<mrow>` instead of `<span>`.
#[component]
pub fn DomChildrenContMath<F:Fn(&Element) -> Option<AnyView<Dom>>+'static+Clone>(orig:OriginalChildren,f:F) -> impl IntoView {
    let span = NodeRef::<Mrow>::new();
    replace(span,orig,Some(f));
    view!(<mrow node_ref=span/>)
}

// This function does the actual work
fn replace<E>(span:NodeRef<E>,_children:OriginalChildren,_f:Option<impl (Fn(&Element) -> Option<AnyView<Dom>>)+'static>)
where
    E: ElementType + 'static,
    E::Output: web_sys::wasm_bindgen::JsCast + AsRef<web_sys::Node> + Clone + 'static,
    {

      let _done = RwSignal::<Option<send_wrapper::SendWrapper<Vec<web_sys::Node>>>>::new(None);
      #[cfg(any(feature="csr",feature="hydrate"))]
      if let Some(f) = &_f {
        //leptos::logging::log!("hydrating early!");
        assert!(_children.0.valid());
        dom::hydrate_node((**_children.0).clone(),&|e| if *e == *_children.0 {None} else {f(e)});
        _done.set(Some(send_wrapper::SendWrapper::new(_children.clone_children()))); 
      }


  // we use an effect to start iterating over the children only after the provided span has been mounted
  Effect::new(move |_| {
    if let Some(_span) = span.get() {
      // in SSR, this should never be called anyway
      #[cfg(any(feature="csr",feature="hydrate"))]
      {
        assert!(_children.0.valid());
        let span:&web_sys::Node = _span.as_ref();
        let p = span.parent_node().unwrap();
        if let Some(children) = _done.get() {
          for c in &*children {
            let _ = p.insert_before(c, Some(span));
            /*if let Some(f) = &_f { 
              // we now recurse over the children. This function does the actual insertion of components into the DOM.
              dom::hydrate_node(c, f) }*/
          }
          let _ = p.remove_child(span);
        } else {
          //leptos::logging::log!("hydrating late!");
          for c in _children.clone_children() {
            let _ = p.insert_before(&c, Some(span));
            if let Some(f) = &_f { 
              // we now recurse over the children. This function does the actual insertion of components into the DOM.
              dom::hydrate_node(c, f) }
          }
          let _ = p.remove_child(span);
        }
      }
    }
  });
}


/// A component that renders a string of valid HTML, and then calls `f` on all the DOM nodes resulting from that to potentially "hydrate" them further.
#[component]
pub fn DomStringCont<F:Fn(&Element) -> Option<AnyView<Dom>>+'static+Clone>(html:String,_f:F) -> impl IntoView {
    let span = NodeRef::<Span>::new();
    // Analogous to the above
    Effect::new(move |_| {
      if let Some(_span) = span.get() {
        #[cfg(any(feature="csr",feature="hydrate"))]
        {
          let span: web_sys::Node = _span.into();
          dom::hydrate_node(span.clone(), &|e| {
            // avoid infinite recursion
            if **e == span { return None }
            _f(e)
          });
          let p = span.parent_node().unwrap();
          while let Some(c) = span.child_nodes().item(0) {
            let _ = p.insert_before(&c, Some(&span));
          }
          let _ = p.remove_child(&span);
        }
      }
    });
    view!(<span node_ref=span inner_html=html/>)
}


/// Like [`DomStringCont`], but using `<mrow>` instead of `<span>`.
#[component]
pub fn DomStringContMath<F:Fn(&Element) -> Option<AnyView<Dom>>+'static+Clone>(html:String,_f:F) -> impl IntoView {
    let span = NodeRef::<Mrow>::new();
    // Analogous to the above
    Effect::new(move |_| {
      if let Some(_span) = span.get() {
        #[cfg(any(feature="csr",feature="hydrate"))]
        {
          let span: web_sys::Node = _span.into();
          dom::hydrate_node(span.clone(), &|e| {
            // avoid infinite recursion
            if **e == span { return None }
            _f(e)
          });
          let p = span.parent_node().unwrap();
          while let Some(c) = span.child_nodes().item(0) {
            let _ = p.insert_before(&c, Some(&span));
          }
          let _ = p.remove_child(&span);
        }
      }
    });
    view!(<mrow node_ref=span inner_html=html/>)
}

// need some check to not iterate over the entire body multiple times for some reason.
// I'm not sure why this is necessary, but it seems to be.
#[cfg(feature="csr")]
static DONE : std::sync::OnceLock<()> = std::sync::OnceLock::new();

/// Hydrates the entire DOM with leptos components, starting at the body.
/// 
/// `v` is a function that takes the [`OriginalChildren`] of the `<body>` (likely reinserting them somewhere) and returns some leptos view replacing the original children(!) of the body.
#[cfg(feature="csr")]
pub fn hydrate_body<N:IntoView>(
  v:impl FnOnce(OriginalChildren) -> N + 'static
) {
  // make sure this only ever happens once.
  if DONE.get().is_some() {return}
  DONE.get_or_init(|| ());
  let document = leptos::tachys::dom::document();
  // We check that the DOM has been fully loaded
  let state = document.ready_state();
  if state == "complete" || state == "interactive" {
    let b = document.body().unwrap();
    let b = OriginalChildren::new(&b);
      mount_to_body(move || {
        v(b)
      });
  } else {
    // maybe this isn't even necessary? If it is, we apparently can't use an FnOnce here, since Closure requires at least FnMut.
    /*  
    let closure = Closure::wrap(Box::new(move |_:Event| {
      mount_to_body(move || {
        v(leptos::tachys::dom::body().into())
      })
    }) as Box<dyn FnMut(_)>);
     document.add_event_listener_with_callback("DOMContentLoaded", closure.as_ref().unchecked_ref()).unwrap();
     closure.forget();
     */
  }
}