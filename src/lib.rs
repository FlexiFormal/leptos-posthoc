/*! Allows for "hydrating" an existent DOM with reactive leptos components,
 * without the entire DOM having to be generated by leptos components.
 * 
 * ## Basic Idea
 * - We provide a function that takes an `&`[`Element`] and optionally returns an [`AnyView`]`<`[`Dom`]`>` that should replace the original element.
 * - If some element is replaced, we first remove all of its children and provide a component [`DomChildren`] that reinserts the original children where we want.
 * - If we want to keep "hydrating" the children of the replaced element, we can use the component [`DomChildrenCont`] that again takes a function `(&`[`Element`]`) -> `[`AnyView`]`<`[`Dom`]`>` and iterates it over all children of the replaced element (transitively).
 * 
 * ## Example
 * Say we want to replace all elements with the attribute `data-replace-with-leptos` with a leptos component `MyReplacementComponent`, that simply wraps the original children in a `div` with a solid red border. This component would roughly look like this:
 * ```
 * #[component]
 * fn MyReplacementComponent(orig:OriginalChildren) -> impl IntoView {
 *    view! {
 *       <div style="border: 1px solid red;">
 *         <DomChildren orig />
 *      </div>
 *   }
 * }
 * ```
 * That is, it takes an `orig:`[`OriginalChildren`] and wraps it in a `div` with a red border, where `orig` represents the original children of the element that was replaced.
 * 
 * So, where do we get `orig` from? 
 * - If we already have an `e:&`[`Element`], we can simply call [`OriginalChildren::new`]`(e)`. That will immediately remove *all* children of `e` and move them into the returned [`OriginalChildren`]. Trouble then is, that the component likely doesn't know where in leptos' reactive graph it should be inserted regarding reactivity (i.e. inheriting context and all that).
 * - More likely, we don't have one yet. In particular in CSR, we probably want to iterate over the entire body *once*. More importantly, we need to set up a global reactive system for all our inserted components.
 * 
 * This is done by calling [`hydrate_body`] (requires the `csr` feature flag) with a function that takes the [`OriginalChildren`] of the body and returns some leptos view replacing the original children(!) of the body. e.g.:
 * 
 * ```
 *  #[component]
 *  fn MainBody(orig:OriginalChildren) -> impl IntoView {
 *     // set up some signals, provide context etc.
 *     view!{
 *       <DomChildren orig/>
 *     }
 *  }
 *  #[wasm_bindgen(start)]
 *   pub fn run() {
 *       console_error_panic_hook::set_once();
 *       hydrate_body(|orig| view!(<MainBody orig/>).into_any())
 *   }
 * ```
 * 
 * This does not yet replace any elements. To do that, we need to provide a function that takes an `&`[`Element`] and returns an [`AnyView`]`<`[`Dom`]`>`. This function is then passed to [`DomChildrenCont`], which will iterate over all children of the replaced element and replace them with the provided function.
 * 
 * For example, let's modify our `MainBody` to iterate over all elements with the attribute `data-replace-with-leptos` and replace them with `MyReplacementComponent`:
 * 
 * ```
 *  fn replace(e:&Element) -> Option<AnyView<Dom>> {
 *    e.get_attribute("data-replace-with-leptos").map(|_| {
 *      let orig = OriginalChildren::new(e);
 *      view!(<MyReplacementComponent orig/>).into_any()
 *    })
 *  }
 *  #[component]
 *  fn MainBody(orig:OriginalChildren) -> impl IntoView {
 *     // set up some signals, provide context etc.
 *     view!{
 *       <DomChildrenCont orig f=replace/>
 *     }
 *  }
 * #[component]
 * fn MyReplacementComponent(orig:OriginalChildren) -> impl IntoView {
 *    view! {
 *       <div style="border: 1px solid red;">
 *         <DomChildrenCont orig f=replace/>
 *      </div>
 *   }
 * }
 * ```
 * 
 * ...now, `replace` will get called on every element of the Dom, including those that were "moved around" in `MyReplacementComponent`, respecting the reactive graph properly hierarchically.
 * 
 * ### So this is only usable in CSR mode?
 * 
 * Not quite, but that's the primary use case - in SSR, you can simply use the normal leptos components to generate the entire DOM, after all.
 * 
 * However, it might occasionally be the case that we dynamically *extend* the DOM at some point by retrieving an HTML string from elsewhere, and then want to do a similar "hydration" iteration over the freshly inserted nodes. This is what [`DomStringCont`] is for, and it does not require the `csr` feature:
 * 
 * ```
 *  #[component]
 *  fn MyComponentThatGetsAStringFromSomewhere() -> impl IntoView {
 *   // get some HTML string from somewhere
 *   // e.g. some API call
 *   let html = "<div data-replace-with-leptos>...</div>".to_string();
 *   view! {
 *     <DomStringCont html f=replace/>
 *   }
 * }
 * ```
 * 
 * **Note** though that this still can only run client-side - after all, server-side, there is no DOM. So make sure that the usage of [`DomStringCont`] is guarded behind e.g. a `#[cfg(feature=...)]`.
*/



pub use dom::OriginalChildren;
#[cfg(any(feature="csr",feature="hydrate"))]
pub use dom::hydrate_node;

/// Re-exports `web_sys::Element` for convenience.
pub use web_sys::Element;

use leptos::{ html::Span, prelude::*};
use tachys::view::any_view::AnyView;

mod dom;

pub(crate) const LOG : bool = false; // just for debugging purposes

macro_rules! log {
  ($($arg:tt)*) => { if $crate::LOG { ::leptos::logging::log!($($arg)*) } }
}

/// A component that takes the [`OriginalChildren`] of some preexistent DOM node, and renders them into the DOM.
#[component]
pub fn DomChildren(orig:OriginalChildren) -> impl IntoView {
    let span = NodeRef::<Span>::new();
    replace(span,orig,Option::<for<'a> fn(&'a _) -> _>::None);
    view!(<span node_ref=span/>)
}

/// A component that takes the [`OriginalChildren`] of some preexistent DOM node and a continuation function `f`, and renders them into the DOM. Additionally, `f` is called on every child of the replaced element, to potentially "hydrate" them further.
#[component]
pub fn DomChildrenCont<F:Fn(&Element) -> Option<AnyView<Dom>>+'static+Clone>(orig:OriginalChildren,f:F) -> impl IntoView {
    log!("Here (DomChildrenCont)");
    let span = NodeRef::<Span>::new();
    replace(span,orig,Some(f));
    view!(<span node_ref=span/>)
}


/// A component that renders a string of valid HTML, and then calls `f` on all the DOM nodes resulting from that to potentially "hydrate" them further.
#[component]
pub fn DomStringCont<F:Fn(&Element) -> Option<AnyView<Dom>>+'static+Clone>(html:String,_f:F) -> impl IntoView {
    log!("Here (DomStringCont)");
    let span = NodeRef::<Span>::new();

    Effect::new(move |_| {
      if let Some(_span) = span.get() {
        #[cfg(any(feature="csr",feature="hydrate"))]
        {
          let span: web_sys::Node = _span.into();
          dom::hydrate_node(span.clone(), &|e| {
            // avoid infinite recursion
            if **e == span { return None }
            _f(e)
          });
          let p = span.parent_node().unwrap();
          while let Some(c) = span.child_nodes().item(0) {
            let _ = p.insert_before(&c, Some(&span));
          }
          let _ = p.remove_child(&span);
        }
      }
    });
    view!(<span node_ref=span inner_html=html/>)
}

// need some check to not iterate over the entire body multiple times for some reason.
// I'm not sure why this is necessary, but it seems to be.
#[cfg(feature="csr")]
static DONE : std::sync::OnceLock<()> = std::sync::OnceLock::new();

/// Hydrates the entire DOM with leptos components, starting at the body.
/// 
/// `v` is a function that takes the [`OriginalChildren`] of the `<body>` (likely reinserting them somewhere) and returns some leptos view replacing the original children(!) of the body.
#[cfg(feature="csr")]
pub fn hydrate_body<N:IntoView>(
  v:impl FnOnce(OriginalChildren) -> N + 'static
) {
  if DONE.get().is_some() {return}
  DONE.get_or_init(|| ());
  let document = leptos::tachys::dom::document();
  let state = document.ready_state();
  if state == "complete" || state == "interactive" {
    let b = document.body().unwrap();
    let b = OriginalChildren::new(&b);
      mount_to_body(move || {
        v(b)
      });
  } else {
    /* // maybe this isn't even necessary? Either 
    let closure = Closure::wrap(Box::new(move |_:Event| {
      mount_to_body(move || {
        v(leptos::tachys::dom::body().into())
      })
    }) as Box<dyn FnMut(_)>);
     */
  }
}

fn replace(span:NodeRef<Span>,_children:OriginalChildren,_f:Option<impl (Fn(&Element) -> Option<AnyView<Dom>>)+'static>) {
  Effect::new(move |_| {
    if let Some(_span) = span.get() {
      #[cfg(any(feature="csr",feature="hydrate"))]
      {
        log!("Span mounted");
        if _children.0.valid() { // <- seems to always be true, but who knows...?
          log!("prior element valid");
          let children = (*_children.0).clone();
          let p = _span.parent_node().unwrap();
          log!("Parent: {p:?}");
          log!("Inserting: {} children", children.len());
          for c in children {
            let _ = p.insert_before(&c, Some(&_span));
            if let Some(f) = &_f { 
              log!("Recursing over: {c:?}");
              dom::hydrate_node(c, f) }
          }
          log!("Removing placeholder span");
          let _ = p.remove_child(&_span);
        } else {
          log!("Prior element invalid!!");
        }
      }
    }
  });
}