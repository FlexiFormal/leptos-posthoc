/*! Allows for "hydrating" an existent DOM with reactive leptos components,
 * without the entire DOM having to be generated by leptos components.
 * 
 * ## Why would you want that?
 * 1. **CSR:** It allows for building scripts that others can just embed in their arbitrary HTML documents, that adds `<insert your favourite fancy feature here>`. For an example, see the `examples/csr` directory: the `index.html` has a node `<script src='csr_example.js'></script>`, which "hydrates" selected nodes (with the `data-replace-with-leptos`-attribute) with leptos components that add a hover-popup (using [thaw](https://docs.rs/thaw)). You too can now do the same for any HTML document you want by just adding the script tag.
 * 2. **SSR:** Occasionally, you might want to dynamically insert some HTML string into the DOM, for example one that gets generated from some data and returned by a server function. This HTML might contain certain nodes that we want to attach reactive functionality to.
 * 
 * ## CSR Example
 * Say we want to replace all elements with the attribute `data-replace-with-leptos` with a leptos component `MyReplacementComponent`, that simply wraps the original children in a `div` with a solid red border. This component would roughly look like this:
 * ```
 * #[component]
 * fn MyReplacementComponent(orig:OriginalNode) -> impl IntoView {
 *    view! {
 *       <div style="border: 1px solid red;">
 *         <DomChildren orig />
 *      </div>
 *   }
 * }
 * ```
 * This component takes an `orig:`[`OriginalChildren`] that represents the "children the original node used to have". They get reinserted where we use the [`DomChildren`] component - i.e. wrapped in a `div` with a red border.
 * 
 * So, where do we get `orig` from? 
 * - If we already have an `e:&`[`Element`], we can simply call [`OriginalChildren::new`]`(e)`. That will immediately remove *all* children of `e` and move them into the returned [`OriginalChildren`]. Trouble then is, that the component likely doesn't know where in leptos' reactive graph it should be inserted regarding reactivity (i.e. inheriting context and all that).
 * - More likely, we don't have an [`Element`] yet. Moreover, we probably want to iterate over the entire body *once* to find all nodes we want to make reactive, and we also need to set up a global reactive system for all our inserted components.
 * 
 * To do that, we call [`hydrate_body`] (requires the `csr` feature flag) with a function that takes the [`OriginalChildren`] of the body and returns some leptos view; e.g.:
 * 
 * ```
 *  #[component]
 *  fn MainBody(orig:OriginalNode) -> impl IntoView {
 *     // set up some signals, provide context etc.
 *     view!{
 *       <DomChildren orig/>
 *     }
 *  }
 *  #[wasm_bindgen(start)]
 *   pub fn run() {
 *       console_error_panic_hook::set_once();
 *       hydrate_body(|orig| view!(<MainBody orig/>).into_any())
 *   }
 * ```
 * 
 * This sets up the reactive system, but does not yet replace any elements further down in the DOM. To do that, we provide a function that takes an `&`[`Element`] and optionally returns an [`AnyView`]`<`[`Dom`]`>`, if the element should be changed. This function is then passed to [`DomChildrenCont`], which will iterate over all children of the replaced element and replace them with the provided function.
 * 
 * Let's modify our `MainBody` to replace all elements with the attribute `data-replace-with-leptos` with a `MyReplacementComponent`:
 * 
 * ```
 *  fn replace(e:&Element) -> Option<AnyView<Dom>> {
 *    e.get_attribute("data-replace-with-leptos").map(|_| {
 *      let orig = e.clone().into();
 *      view!(<MyReplacementComponent orig/>).into_any()
 *    })
 *  }
 * 
 *  #[component]
 *  fn MainBody(orig:OriginalNode) -> impl IntoView {
 *     // set up some signals, provide context etc.
 *     view!{
 *       <DomChildrenCont orig cont=replace/>
 *     }
 *  }
 * 
 * #[component]
 * fn MyReplacementComponent(orig:OriginalNode) -> impl IntoView {
 *    view! {
 *       <div style="border: 1px solid red;">
 *         <DomChildrenCont orig cont=replace/>
 *      </div>
 *   }
 * }
 * ```
 * 
 * ...now, `replace` will get called on every element of the DOM, including those that were "moved around" in earlier `MyReplacementComponent`s, respecting the reactive graph properly hierarchically.
 * 
 * ### SSR Example
 * 
 * In general, for SSR we can simply use the normal leptos components to generate the entire DOM. We control the server, hence we control the DOM anyway.
 * 
 * However, it might occasionally be the case that we want to dynamically *extend* the DOM at some point by retrieving HTML from elsewhere, and then want to do a similar "hydration" iteration over the freshly inserted nodes. This is what [`DomStringCont`] is for, and it does not require the `csr` feature:
 * 
 * ```
 *  #[component]
 *  fn MyComponentThatGetsAStringFromSomewhere() -> impl IntoView {
 *   // get some HTML string from somewhere
 *   // e.g. some API call
 *   let html = "<div data-replace-with-leptos>...</div>".to_string();
 *   view! {
 *     <DomStringCont html cont=replace/>
 *   }
 * }
 * ```
 * 
 * See the `examples/ssr` directory for a full example.
*/

mod node;
mod dom;

pub use node::OriginalNode;

#[cfg(any(feature="csr",feature="hydrate"))]
pub use dom::hydrate_node;

use leptos::{web_sys::Element, html::{ElementType, Span}, math::Mrow, prelude::*};
use tachys::view::any_view::AnyView;
use web_sys::HtmlElement;



/// A component that inserts the  children of some [`OriginalNode`] 
/// and renders them into the DOM.
#[component]
pub fn DomChildren(orig:OriginalNode) -> impl IntoView {
    orig.children_into_view()
}

/// A component that takes the [`OriginalChildren`] of some preexistent DOM node and a continuation function `f`, and renders them into the DOM. Additionally, `f` is called on every child of the replaced element, to potentially "hydrate" them further.
#[component]
pub fn DomChildrenCont<F:Fn(&Element) -> Option<AnyView<Dom>>+'static+Clone>(orig:OriginalNode,cont:F) -> impl IntoView {
    orig.children_into_view_cont(cont)
}

/// A component that calls `f` on all children of `orig`
/// to potentially "hydrate" them further, and reinserts the original
/// element into the DOM.
#[component]
pub fn DomCont<F:Fn(&Element) -> Option<AnyView<Dom>>+'static+Clone>(#[allow(unused_variables)]orig:OriginalNode,#[allow(unused_variables)]cont:F) -> impl IntoView {
    orig.into_view_cont(cont)
}

/// A component that renders a string of valid HTML, and then calls `f` on all the DOM nodes resulting from that to potentially "hydrate" them further.
#[component]
pub fn DomStringCont<F:Fn(&Element) -> Option<AnyView<Dom>>+'static+Clone>(html:String,cont:F) -> impl IntoView {
    let rf = NodeRef::<Span>::new();
    replace_string_effect(rf,|e| (**e).clone(), cont);
    view!(<span node_ref=rf inner_html=html/>)
}

/// Like [`DomStringCont`], but using `<mrow>` instead of `<span>`.
#[component]
pub fn DomStringContMath<F:Fn(&Element) -> Option<AnyView<Dom>>+'static+Clone>(html:String,cont:F) -> impl IntoView {
    let rf = NodeRef::<Mrow>::new();
    replace_string_effect(rf,|e| e, cont);
    view!(<mrow node_ref=rf inner_html=html/>)
}

// ------------------------------------------------------------

#[cfg(any(feature="csr",feature="hydrate"))]
pub(crate) fn on_mount(mut node:Element,mut then:impl FnMut(&mut Element) + 'static) {
  use wasm_bindgen::JsCast;
  if node.parent_element().is_some() {
    then(&mut node);
  } else {
    let observer = std::rc::Rc::new(std::cell::Cell::new(Option::<web_sys::MutationObserver>::None));
    let obs = observer.clone();
    let callback : wasm_bindgen::prelude::Closure<dyn FnMut(_,_)> = wasm_bindgen::closure::Closure::new(
      move |mutations: web_sys::js_sys::Array,_:web_sys::MutationObserver| {
        for i in 0..mutations.length() {
          let mutation: Result<web_sys::MutationRecord,_> = mutations.get(i).dyn_into();
          if let Ok(mutation) = mutation {
            let added_nodes = mutation.added_nodes();
            for j in 0..added_nodes.length() {
              let added_node = added_nodes.get(j);
              if added_node.map(|n| n == *node).unwrap_or_default() {
                then(&mut node);
                if let Some(o) = obs.take() {
                  o.disconnect();
                }
                return
              }
            }
          }
        }
    });
    let obs_init = web_sys::MutationObserverInit::new();
    obs_init.set_child_list(true);
    obs_init.set_subtree(true);
    let obs = web_sys::MutationObserver::new(callback.as_ref().unchecked_ref()).expect("Error creating MutationObserver");
    obs.observe_with_options(&document().body().unwrap(), &obs_init).expect("Error initializing MutationObserver");
    observer.set(Some(obs));
    callback.forget();
  }
}

#[allow(unused_variables)]
fn replace_string_effect<E,F:Fn(&Element) -> Option<AnyView<Dom>>+'static+Clone>(rf:NodeRef<E>,conv:impl Fn(E::Output) -> Element + 'static,cont:F)
where
    E: ElementType + 'static,
    E::Output:leptos::wasm_bindgen::JsCast + Clone + 'static {
  Effect::new(move |_| if let Some(node) = rf.get() {
    #[cfg(any(feature="csr",feature="hydrate"))]
    {
      let node = conv(node);
      dom::hydrate_children((*node).clone(), &cont);
      on_mount(node,|node| {
        while let Some(mut c) = node.child_nodes().item(0) {
          if !node.insert_before_this(&mut c) {
            panic!("ERROR: Failed to insert child node!!");
          }
        }
        node.unmount();
      });
      
      /*let parent = node.parent_node().unwrap_or_else(|| {
        leptos::logging::log!("ERROR leptos-dyn-dom: No parent node found");
        panic!("ERROR leptos-dyn-dom: No parent node found");
      });
      while let Some(c) = node.child_nodes().item(0) {
        let _ = parent.insert_before(&c, Some(node));
      }
      let _ = parent.remove_child(node);*/
    }
  });
}

// need some check to not iterate over the entire body multiple times for some reason.
// I'm not sure why this is necessary, but it seems to be.
#[cfg(feature="csr")]
static DONE : std::sync::OnceLock<()> = std::sync::OnceLock::new();

/// Hydrates the entire DOM with leptos components, starting at the body.
/// 
/// `v` is a function that takes the [`OriginalChildren`] of the `<body>` (likely reinserting them somewhere) and returns some leptos view replacing the original children(!) of the body.
#[cfg(feature="csr")]
pub fn hydrate_body<N:IntoView>(
  v:impl FnOnce(OriginalNode) -> N + 'static
) {
  // make sure this only ever happens once.
  if DONE.get().is_some() {return}
  DONE.get_or_init(|| ());
  let document = leptos::tachys::dom::document();
  // We check that the DOM has been fully loaded
  let state = document.ready_state();
  if state == "complete" || state == "interactive" {
    let b = document.body().unwrap_or_else(|| {
      leptos::logging::log!("ERROR leptos-dyn-dom: No <body>> node found for span");
      panic!("ERROR leptos-dyn-dom: No <body>> node found for span");
    });
    let b = b.clone().into();
      mount_to_body(move || {
        let r = v(b);
        r
      });
  } else {
    use wasm_bindgen::JsCast;
    let fun = std::rc::Rc::new(std::cell::RefCell::new(Some(v)));
    let closure = wasm_bindgen::closure::Closure::wrap(Box::new(move |_:web_sys::Event| {
      if let Some(f) = fun.borrow_mut().take() {
        let body = leptos::tachys::dom::body();
        let body = body.clone().into();
        mount_to_body(move || { 
          let r = f(body);
          r
        })
      }
    }) as Box<dyn FnMut(_)>);
     document.add_event_listener_with_callback("DOMContentLoaded", closure.as_ref().unchecked_ref()).unwrap();
     closure.forget();
  }
}